import {
  collection,
  doc,
  getDocs,
  getDoc,
  addDoc,
  updateDoc,
  deleteDoc,
  query,
  where,
  orderBy,
  limit,
  onSnapshot,
  serverTimestamp,
  Timestamp,
  setDoc,
} from 'firebase/firestore';
import { db } from '../config/firebase';
import { Customer, Quote, Invoice, EmailHistory, CalendarEvent, ShareLink } from '../types';

class FirebaseService {
  // Collections - nur initialisieren wenn db vorhanden (lazy loading to prevent errors)
  private customersCollection: any = null;
  private quotesCollection: any = null;
  private invoicesCollection: any = null;
  private emailHistoryCollection: any = null;
  private dispositionsCollection: any = null;
  private shareLinksCollection: any = null;
  private calendarEventsCollection: any = null;

  // Lazy initialization of collections
  private getCustomersCollection() {
    if (!this.customersCollection && db) {
      this.customersCollection = collection(db, 'customers');
    }
    return this.customersCollection;
  }

  private getQuotesCollection() {
    if (!this.quotesCollection && db) {
      this.quotesCollection = collection(db, 'quotes');
    }
    return this.quotesCollection;
  }

  private getInvoicesCollection() {
    if (!this.invoicesCollection && db) {
      this.invoicesCollection = collection(db, 'invoices');
    }
    return this.invoicesCollection;
  }

  private getEmailHistoryCollection() {
    if (!this.emailHistoryCollection && db) {
      this.emailHistoryCollection = collection(db, 'emailHistory');
    }
    return this.emailHistoryCollection;
  }

  private getDispositionsCollection() {
    if (!this.dispositionsCollection && db) {
      this.dispositionsCollection = collection(db, 'dispositions');
    }
    return this.dispositionsCollection;
  }

  private getShareLinksCollection() {
    if (!this.shareLinksCollection && db) {
      this.shareLinksCollection = collection(db, 'shareLinks');
    }
    return this.shareLinksCollection;
  }

  private getCalendarEventsCollection() {
    if (!this.calendarEventsCollection && db) {
      this.calendarEventsCollection = collection(db, 'calendarEvents');
    }
    return this.calendarEventsCollection;
  }

  // Pr√ºfe ob Firebase verf√ºgbar ist
  private checkFirebase(): boolean {
    if (!db) {
      console.warn('‚ö†Ô∏è Firebase nicht verf√ºgbar - bitte konfigurieren Sie Firebase in .env.local');
      return false;
    }
    return true;
  }

  // ==================== CUSTOMERS ====================
  
  async getCustomers(): Promise<Customer[]> {
    const customersCollection = this.getCustomersCollection();
    if (!this.checkFirebase() || !customersCollection) {
      return [];
    }
    
    try {
      console.log('üìä Lade Kunden aus Firestore...');
      const querySnapshot = await getDocs(customersCollection);
      
      const customers: Customer[] = [];
      querySnapshot.forEach((doc) => {
        const data = doc.data();
        try {
          const customerData: any = {
            id: doc.id,
            ...(data || {}),
            createdAt: (data as any)?.createdAt && typeof (data as any).createdAt.toDate === 'function' 
              ? (data as any).createdAt.toDate() 
              : (data as any)?.createdAt || new Date(),
          };
          
          // Skip salesNotes for now to avoid errors
          if (customerData.salesNotes) {
            delete customerData.salesNotes;
          }
          
          // Convert cancelledAt if exists
          if (customerData.cancelledAt && typeof customerData.cancelledAt.toDate === 'function') {
            customerData.cancelledAt = customerData.cancelledAt.toDate();
          }
          
          customers.push(customerData as Customer);
        } catch (error) {
          console.warn(`‚ö†Ô∏è Fehler beim Verarbeiten von Kunde ${doc.id}:`, error);
          // F√ºge Kunde trotzdem hinzu, nur mit Name
          customers.push({
            id: doc.id,
            ...(data || {}),
            createdAt: new Date(),
          } as Customer);
        }
      });
      
      console.log(`‚úÖ ${customers.length} Kunden aus Firestore geladen`);
      return customers;
    } catch (error) {
      console.error('‚ùå Fehler beim Laden der Kunden aus Firestore:', error);
      throw error;
    }
  }

  async getCustomerById(customerId: string): Promise<Customer | null> {
    try {
      const customersCollection = this.getCustomersCollection();
      if (!customersCollection) {
        console.error('Customers collection not initialized');
        return null;
      }
      
      // Versuche zuerst mit der direkten ID
      const docRef = doc(customersCollection, customerId);
      const docSnap = await getDoc(docRef);
      
      if (docSnap.exists()) {
        const data = docSnap.data();
        const customerData: any = {
          id: docSnap.id,
          ...data,
          createdAt: data.createdAt && typeof data.createdAt.toDate === 'function' 
            ? data.createdAt.toDate() 
            : data.createdAt || new Date(),
        };
        
        // Skip salesNotes for now to avoid errors
        if (customerData.salesNotes) {
          delete customerData.salesNotes;
        }
        
        // Convert cancelledAt if exists
        if (customerData.cancelledAt && typeof customerData.cancelledAt.toDate === 'function') {
          customerData.cancelledAt = customerData.cancelledAt.toDate();
        }
        
        return customerData as Customer;
      }
      
      // Wenn nicht gefunden, suche nach Kundennummer
      console.log(`‚ö†Ô∏è Kunde mit ID ${customerId} nicht gefunden, suche nach Kundennummer...`);
      const q = query(customersCollection, where('customerNumber', '==', customerId));
      const querySnapshot = await getDocs(q);
      
      if (!querySnapshot.empty) {
        const foundDoc = querySnapshot.docs[0];
        const data = foundDoc.data();
        console.log(`‚úÖ Kunde gefunden mit Firebase ID: ${foundDoc.id}`);
        
        const customerData: any = {
          id: foundDoc.id,
          ...data,
          createdAt: data.createdAt && typeof data.createdAt.toDate === 'function' 
            ? data.createdAt.toDate() 
            : data.createdAt || new Date(),
        };
        
        // Skip salesNotes for now to avoid errors
        if (customerData.salesNotes) {
          delete customerData.salesNotes;
        }
        
        // Convert cancelledAt if exists
        if (customerData.cancelledAt && typeof customerData.cancelledAt.toDate === 'function') {
          customerData.cancelledAt = customerData.cancelledAt.toDate();
        }
        
        return customerData as Customer;
      }
      
      return null;
    } catch (error) {
      console.error('‚ùå Fehler beim Laden des Kunden:', error);
      throw error;
    }
  }

  async addCustomer(customer: Omit<Customer, 'id'>): Promise<string> {
    try {
      // Generiere Kundennummer wenn nicht vorhanden
      const customerNumber = customer.customerNumber || await this.generateCustomerNumber();
      
      const customersCollection = this.getCustomersCollection();
      if (!customersCollection) throw new Error('Customers collection not initialized');
      
      // Filter out undefined values
      const customerData: any = {
        ...customer,
        customerNumber,
        createdAt: serverTimestamp(),
        updatedAt: serverTimestamp(),
      };
      
      // Remove undefined fields
      Object.keys(customerData).forEach(key => {
        if (customerData[key] === undefined) {
          delete customerData[key];
        }
      });
      
      const docRef = await addDoc(customersCollection, customerData);
      
      console.log('‚úÖ Kunde in Firestore erstellt:', docRef.id, 'mit Kundennummer:', customerNumber);
      return docRef.id;
    } catch (error) {
      console.error('‚ùå Fehler beim Erstellen des Kunden:', error);
      throw error;
    }
  }

  async updateCustomer(customerId: string, updates: Partial<Customer>): Promise<void> {
    try {
      const customersCollection = this.getCustomersCollection();
      if (!customersCollection) throw new Error('Customers collection not initialized');
      const docRef = doc(customersCollection, customerId);
      
      // Filter out undefined values and convert dates
      const updateData: any = {
        ...updates,
        updatedAt: serverTimestamp(),
      };
      
      // Skip salesNotes updates for now
      if (updateData.salesNotes) {
        delete updateData.salesNotes;
      }
      
      // Convert other date fields
      if (updateData.cancelledAt && updateData.cancelledAt instanceof Date) {
        updateData.cancelledAt = Timestamp.fromDate(updateData.cancelledAt);
      }
      
      // Remove undefined fields
      Object.keys(updateData).forEach(key => {
        if (updateData[key] === undefined) {
          delete updateData[key];
        }
      });
      
      await updateDoc(docRef, updateData);
      console.log('‚úÖ Kunde aktualisiert:', customerId);
    } catch (error) {
      console.error('‚ùå Fehler beim Aktualisieren des Kunden:', error);
      throw error;
    }
  }

  async deleteCustomer(customerId: string): Promise<void> {
    try {
      const customersCollection = this.getCustomersCollection();
      if (!customersCollection) throw new Error('Customers collection not initialized');
      const docRef = doc(customersCollection, customerId);
      await deleteDoc(docRef);
      console.log('‚úÖ Kunde gel√∂scht:', customerId);
    } catch (error) {
      console.error('‚ùå Fehler beim L√∂schen des Kunden:', error);
      throw error;
    }
  }

  // ==================== QUOTES ====================

  async getQuotes(): Promise<Quote[]> {
    try {
      const quotesCollection = this.getQuotesCollection();
      if (!quotesCollection) return [];
      const querySnapshot = await getDocs(quotesCollection);
      
      const quotes: Quote[] = [];
      querySnapshot.forEach((doc) => {
        const data = doc.data();
        quotes.push({
          id: doc.id,
          ...data,
          createdAt: data.createdAt && typeof data.createdAt.toDate === 'function'
            ? data.createdAt.toDate()
            : data.createdAt || new Date(),
        } as Quote);
      });
      
      return quotes;
    } catch (error) {
      console.error('‚ùå Fehler beim Laden der Angebote:', error);
      throw error;
    }
  }

  async getQuoteById(quoteId: string): Promise<Quote | null> {
    try {
      const quotesCollection = this.getQuotesCollection();
      if (!quotesCollection) {
        console.error('Quotes collection not initialized');
        return null;
      }
      const docRef = doc(quotesCollection, quoteId);
      const docSnap = await getDoc(docRef);
      
      if (docSnap.exists()) {
        const data = docSnap.data();
        return {
          id: docSnap.id,
          ...data,
          createdAt: data.createdAt && typeof data.createdAt.toDate === 'function'
            ? data.createdAt.toDate()
            : data.createdAt || new Date(),
        } as Quote;
      }
      return null;
    } catch (error) {
      console.error('‚ùå Fehler beim Laden des Angebots:', error);
      throw error;
    }
  }

  async getQuotesByCustomerId(customerId: string): Promise<Quote[]> {
    try {
      if (!this.getQuotesCollection()) return [];
      const q = query(
        this.getQuotesCollection(),
        where('customerId', '==', customerId),
        orderBy('createdAt', 'desc')
      );
      
      const querySnapshot = await getDocs(q);
      const quotes: Quote[] = [];
      
      querySnapshot.forEach((doc) => {
        const data = doc.data();
        quotes.push({
          id: doc.id,
          ...data,
          createdAt: data.createdAt && typeof data.createdAt.toDate === 'function'
            ? data.createdAt.toDate()
            : data.createdAt || new Date(),
        } as Quote);
      });
      
      return quotes;
    } catch (error) {
      console.error('‚ùå Fehler beim Laden der Kundenangebote:', error);
      throw error;
    }
  }

  async addQuote(quote: Omit<Quote, 'id'>): Promise<string> {
    try {
      if (!this.getQuotesCollection()) throw new Error('Quotes collection not initialized');
      
      // Filter out undefined values
      const quoteData: any = {
        ...quote,
        createdAt: serverTimestamp(),
        updatedAt: serverTimestamp(),
      };
      
      // Remove undefined fields
      Object.keys(quoteData).forEach(key => {
        if (quoteData[key] === undefined) {
          delete quoteData[key];
        }
      });
      
      const docRef = await addDoc(this.getQuotesCollection(), quoteData);
      
      console.log('‚úÖ Angebot in Firestore erstellt:', docRef.id);
      return docRef.id;
    } catch (error) {
      console.error('‚ùå Fehler beim Erstellen des Angebots:', error);
      throw error;
    }
  }

  async updateQuote(quoteId: string, updates: Partial<Quote>): Promise<void> {
    try {
      if (!this.getQuotesCollection()) throw new Error('Quotes collection not initialized');
      
      // Versuche zuerst mit der direkten ID
      let docRef = doc(this.getQuotesCollection(), quoteId);
      let docSnapshot = await getDoc(docRef);
      
      // Wenn das Dokument nicht existiert, suche nach der numerischen ID
      if (!docSnapshot.exists()) {
        console.log(`‚ö†Ô∏è Dokument mit ID ${quoteId} nicht gefunden, suche nach numerischer ID...`);
        
        // Suche das Dokument mit der numerischen ID im Datenfeld
        const q = query(this.getQuotesCollection(), where('id', '==', quoteId));
        const querySnapshot = await getDocs(q);
        
        if (!querySnapshot.empty) {
          // Verwende die Firebase Document ID des gefundenen Dokuments
          const foundDoc = querySnapshot.docs[0];
          docRef = foundDoc.ref;
          console.log(`‚úÖ Dokument gefunden mit Firebase ID: ${foundDoc.id}`);
        } else {
          throw new Error(`Angebot mit ID ${quoteId} nicht gefunden`);
        }
      }
      
      // Filter out undefined values
      const updateData: any = {
        ...updates,
        updatedAt: serverTimestamp(),
      };
      
      // Remove undefined fields
      Object.keys(updateData).forEach(key => {
        if (updateData[key] === undefined) {
          delete updateData[key];
        }
      });
      
      await updateDoc(docRef, updateData);
      console.log('‚úÖ Angebot aktualisiert:', quoteId);
    } catch (error) {
      console.error('‚ùå Fehler beim Aktualisieren des Angebots:', error);
      throw error;
    }
  }

  async deleteQuote(quoteId: string): Promise<void> {
    try {
      if (!this.getQuotesCollection()) throw new Error('Quotes collection not initialized');
      const docRef = doc(this.getQuotesCollection(), quoteId);
      await deleteDoc(docRef);
      console.log('‚úÖ Angebot gel√∂scht:', quoteId);
    } catch (error) {
      console.error('‚ùå Fehler beim L√∂schen des Angebots:', error);
      throw error;
    }
  }

  // ==================== INVOICES ====================

  async getInvoices(): Promise<Invoice[]> {
    try {
      if (!this.getInvoicesCollection()) return [];
      const querySnapshot = await getDocs(this.getInvoicesCollection());
      
      const invoices: Invoice[] = [];
      querySnapshot.forEach((doc) => {
        const data = doc.data();
        try {
          invoices.push({
            id: doc.id,
            ...data,
            createdAt: data.createdAt && typeof data.createdAt.toDate === 'function'
              ? data.createdAt.toDate()
              : data.createdAt || new Date(),
            dueDate: data.dueDate && typeof data.dueDate.toDate === 'function'
              ? data.dueDate.toDate()
              : data.dueDate || new Date(),
            paidDate: data.paidDate && typeof data.paidDate.toDate === 'function'
              ? data.paidDate.toDate()
              : data.paidDate,
          } as Invoice);
        } catch (error) {
          console.warn(`‚ö†Ô∏è Fehler beim Verarbeiten von Rechnung ${doc.id}:`, error);
        }
      });
      
      return invoices;
    } catch (error) {
      console.error('‚ùå Fehler beim Laden der Rechnungen:', error);
      throw error;
    }
  }

  async getInvoiceById(invoiceId: string): Promise<Invoice | null> {
    try {
      if (!this.getInvoicesCollection()) {
        console.error('Invoices collection not initialized');
        return null;
      }
      const docRef = doc(this.getInvoicesCollection(), invoiceId);
      const docSnap = await getDoc(docRef);
      
      if (docSnap.exists()) {
        const data = docSnap.data();
        return {
          id: docSnap.id,
          ...data,
          createdAt: data.createdAt && typeof data.createdAt.toDate === 'function'
            ? data.createdAt.toDate()
            : data.createdAt || new Date(),
          dueDate: data.dueDate && typeof data.dueDate.toDate === 'function'
            ? data.dueDate.toDate()
            : data.dueDate || new Date(),
          paidDate: data.paidDate && typeof data.paidDate.toDate === 'function'
            ? data.paidDate.toDate()
            : data.paidDate,
        } as Invoice;
      }
      return null;
    } catch (error) {
      console.error('‚ùå Fehler beim Laden der Rechnung:', error);
      throw error;
    }
  }

  async getInvoicesByCustomer(customerId: string): Promise<Invoice[]> {
    try {
      if (!this.getInvoicesCollection()) return [];
      const q = query(
        this.getInvoicesCollection(),
        where('customerId', '==', customerId),
        orderBy('createdAt', 'desc')
      );
      
      const querySnapshot = await getDocs(q);
      const invoices: Invoice[] = [];
      
      querySnapshot.forEach((doc) => {
        const data = doc.data();
        invoices.push({
          id: doc.id,
          ...data,
          createdAt: data.createdAt && typeof data.createdAt.toDate === 'function'
            ? data.createdAt.toDate()
            : data.createdAt || new Date(),
          dueDate: data.dueDate && typeof data.dueDate.toDate === 'function'
            ? data.dueDate.toDate()
            : data.dueDate || new Date(),
          paidDate: data.paidDate && typeof data.paidDate.toDate === 'function'
            ? data.paidDate.toDate()
            : data.paidDate,
        } as Invoice);
      });
      
      return invoices;
    } catch (error) {
      console.error('‚ùå Fehler beim Laden der Kundenrechnungen:', error);
      throw error;
    }
  }

  async addInvoice(invoice: Omit<Invoice, 'id'>): Promise<string> {
    try {
      if (!this.getInvoicesCollection()) throw new Error('Invoices collection not initialized');
      
      // Filter out undefined values
      const invoiceData: any = {
        ...invoice,
        createdAt: serverTimestamp(),
        updatedAt: serverTimestamp(),
      };
      
      // Remove undefined fields
      if (invoiceData.paidDate === undefined) {
        delete invoiceData.paidDate;
      }
      
      const docRef = await addDoc(this.getInvoicesCollection(), invoiceData);
      
      console.log('‚úÖ Rechnung in Firestore erstellt:', docRef.id);
      return docRef.id;
    } catch (error) {
      console.error('‚ùå Fehler beim Erstellen der Rechnung:', error);
      throw error;
    }
  }

  async updateInvoice(invoiceId: string, updates: Partial<Invoice>): Promise<void> {
    try {
      if (!this.getInvoicesCollection()) throw new Error('Invoices collection not initialized');
      const docRef = doc(this.getInvoicesCollection(), invoiceId);
      
      // Filter out undefined values
      const updateData: any = {
        ...updates,
        updatedAt: serverTimestamp(),
      };
      
      // Remove undefined fields
      Object.keys(updateData).forEach(key => {
        if (updateData[key] === undefined) {
          delete updateData[key];
        }
      });
      
      await updateDoc(docRef, updateData);
      console.log('‚úÖ Rechnung aktualisiert:', invoiceId);
    } catch (error) {
      console.error('‚ùå Fehler beim Aktualisieren der Rechnung:', error);
      throw error;
    }
  }

  async deleteInvoice(invoiceId: string): Promise<void> {
    try {
      if (!this.getInvoicesCollection()) throw new Error('Invoices collection not initialized');
      const docRef = doc(this.getInvoicesCollection(), invoiceId);
      await deleteDoc(docRef);
      console.log('‚úÖ Rechnung gel√∂scht:', invoiceId);
    } catch (error) {
      console.error('‚ùå Fehler beim L√∂schen der Rechnung:', error);
      throw error;
    }
  }

  // ==================== EMAIL HISTORY ====================

  async getEmailHistory(customerId?: string): Promise<EmailHistory[]> {
    try {
      if (!this.getEmailHistoryCollection()) throw new Error('Email history collection not initialized');
      
      let q;
      if (customerId) {
        q = query(
          this.getEmailHistoryCollection(),
          where('customerId', '==', customerId),
          orderBy('sentAt', 'desc')
        );
      } else {
        q = query(this.getEmailHistoryCollection(), orderBy('sentAt', 'desc'), limit(100));
      }
      
      const querySnapshot = await getDocs(q);
      const emails: EmailHistory[] = [];
      
      querySnapshot.forEach((doc) => {
        const data = doc.data() as any;
        emails.push({
          id: doc.id,
          ...data,
          sentAt: data.sentAt && typeof data.sentAt.toDate === 'function'
            ? data.sentAt.toDate()
            : data.sentAt || new Date(),
        } as EmailHistory);
      });
      
      return emails;
    } catch (error) {
      console.error('‚ùå Fehler beim Laden der E-Mail-Historie:', error);
      throw error;
    }
  }

  async addEmailHistory(email: Omit<EmailHistory, 'id'>): Promise<string> {
    try {
      if (!this.getEmailHistoryCollection()) throw new Error('Email history collection not initialized');
      const docRef = await addDoc(this.getEmailHistoryCollection(), {
        ...email,
        sentAt: serverTimestamp(),
      });
      
      console.log('‚úÖ E-Mail-Historie in Firestore gespeichert:', docRef.id);
      return docRef.id;
    } catch (error) {
      console.error('‚ùå Fehler beim Speichern der E-Mail-Historie:', error);
      throw error;
    }
  }

  // ==================== REAL-TIME LISTENERS ====================

  subscribeToCustomers(callback: (customers: Customer[]) => void): () => void {
    const customersCollection = this.getCustomersCollection();
    if (!customersCollection) {
      console.warn('Customers collection not initialized');
      return () => {};
    }
    const unsubscribe = onSnapshot(customersCollection, (snapshot) => {
      const customers: Customer[] = [];
      snapshot.forEach((doc) => {
        const data = doc.data();
        const customerData: any = {
          id: doc.id,
          ...data,
          createdAt: data.createdAt && typeof data.createdAt.toDate === 'function'
            ? data.createdAt.toDate()
            : data.createdAt || new Date(),
        };
        
        // Skip salesNotes for now to avoid errors
        if (customerData.salesNotes) {
          delete customerData.salesNotes;
        }
        
        // Convert cancelledAt if exists
        if (customerData.cancelledAt && typeof customerData.cancelledAt.toDate === 'function') {
          customerData.cancelledAt = customerData.cancelledAt.toDate();
        }
        
        customers.push(customerData as Customer);
      });
      callback(customers);
    });
    
    return unsubscribe;
  }

  subscribeToQuotes(callback: (quotes: Quote[]) => void): () => void {
    if (!this.getQuotesCollection()) {
      console.warn('Quotes collection not initialized');
      return () => {};
    }
    const unsubscribe = onSnapshot(this.getQuotesCollection(), (snapshot) => {
      const quotes: Quote[] = [];
      snapshot.forEach((doc) => {
        const data = doc.data();
        quotes.push({
          id: doc.id,
          ...data,
          createdAt: data.createdAt && typeof data.createdAt.toDate === 'function'
            ? data.createdAt.toDate()
            : data.createdAt || new Date(),
        } as Quote);
      });
      callback(quotes);
    });
    
    return unsubscribe;
  }

  subscribeToInvoices(callback: (invoices: Invoice[]) => void): () => void {
    if (!this.getInvoicesCollection()) {
      console.warn('Invoices collection not initialized');
      return () => {};
    }
    const unsubscribe = onSnapshot(this.getInvoicesCollection(), (snapshot) => {
      const invoices: Invoice[] = [];
      snapshot.forEach((doc) => {
        const data = doc.data();
        invoices.push({
          id: doc.id,
          ...data,
          createdAt: data.createdAt && typeof data.createdAt.toDate === 'function'
            ? data.createdAt.toDate()
            : data.createdAt || new Date(),
          dueDate: data.dueDate && typeof data.dueDate.toDate === 'function'
            ? data.dueDate.toDate()
            : data.dueDate || new Date(),
          paidDate: data.paidDate && typeof data.paidDate.toDate === 'function'
            ? data.paidDate.toDate()
            : data.paidDate,
        } as Invoice);
      });
      callback(invoices);
    });
    
    return unsubscribe;
  }

  // ==================== HELPER FUNCTIONS ====================

  private async generateCustomerNumber(): Promise<string> {
    const date = new Date();
    const year = date.getFullYear();
    const month = String(date.getMonth() + 1).padStart(2, '0');
    
    const customersCollection = this.getCustomersCollection();
    if (!customersCollection) throw new Error('Customers collection not initialized');
    
    // Query for customers with customer numbers starting with the current year and month
    const prefix = `K${year}${month}`;
    const q = query(
      customersCollection,
      where('customerNumber', '>=', prefix),
      where('customerNumber', '<', prefix + '\uf8ff'),
      orderBy('customerNumber', 'desc'),
      limit(1)
    );
    
    const snapshot = await getDocs(q);
    
    let nextNumber = 1;
    if (!snapshot.empty) {
      const lastCustomerNumber = snapshot.docs[0].data().customerNumber;
      // Extract the number part (last 3 digits)
      const lastNumber = parseInt(lastCustomerNumber.slice(-3));
      nextNumber = lastNumber + 1;
    }
    
    return `${prefix}${String(nextNumber).padStart(3, '0')}`;
  }

  // ==================== MIGRATION HELPERS ====================

  async migrateCustomerFromGoogleSheets(customer: Customer): Promise<void> {
    try {
      const customersCollection = this.getCustomersCollection();
      if (!customersCollection) throw new Error('Customers collection not initialized');
      
      // Skip if customerNumber is undefined or empty
      if (!customer.customerNumber) {
        console.warn('‚ö†Ô∏è Kunde ohne Kundennummer √ºbersprungen:', customer.id);
        return;
      }
      
      // Check if customer already exists
      const q = query(customersCollection, where('customerNumber', '==', customer.customerNumber));
      const snapshot = await getDocs(q);
      
      if (snapshot.empty) {
        // Create new customer
        await setDoc(doc(customersCollection, customer.id), {
          ...customer,
          migratedFrom: 'googleSheets',
          migratedAt: serverTimestamp(),
        });
        console.log('‚úÖ Kunde migriert:', customer.customerNumber);
      } else {
        console.log('‚è≠Ô∏è Kunde bereits vorhanden:', customer.customerNumber);
      }
    } catch (error) {
      console.error('‚ùå Fehler bei Migration:', error);
      throw error;
    }
  }

  async migrateQuoteFromGoogleSheets(quote: Quote): Promise<void> {
    try {
      if (!this.getQuotesCollection()) throw new Error('Quotes collection not initialized');
      await setDoc(doc(this.getQuotesCollection(), quote.id), {
        ...quote,
        migratedFrom: 'googleSheets',
        migratedAt: serverTimestamp(),
      });
      console.log('‚úÖ Angebot migriert:', quote.id);
    } catch (error) {
      console.error('‚ùå Fehler bei Angebots-Migration:', error);
      throw error;
    }
  }

  // ==================== SHARE LINKS ====================

  async createShareLink(customerId: string, quoteId: string, createdBy?: string, additionalData?: any): Promise<ShareLink> {
    try {
      if (!this.getShareLinksCollection()) throw new Error('ShareLinks collection not initialized');
      
      // Generate unique token
      const rawToken = `${customerId}-${Date.now()}-${Math.random()}`;
      const token = btoa(rawToken).replace(/[^a-zA-Z0-9]/g, '').substring(0, 32);
      
      console.log('üîë Generiere ShareLink Token:', {
        customerId,
        quoteId,
        rawToken: rawToken.substring(0, 20) + '...',
        generatedToken: token,
        tokenLength: token.length
      });
      
      // Create expiration date (7 days from now)
      const expiresAt = new Date();
      expiresAt.setDate(expiresAt.getDate() + 7);
      
      const shareLinkData = {
        customerId,
        quoteId,
        token,
        expiresAt: Timestamp.fromDate(expiresAt),
        createdAt: serverTimestamp(),
        createdBy,
        ...(additionalData || {}), // Add any additional data (like arbeitsscheinHTML)
      };
      
      console.log('üìù ShareLink Daten vor Speicherung:', {
        ...shareLinkData,
        arbeitsscheinHTML: additionalData?.arbeitsscheinHTML ? 'Vorhanden' : 'Nicht vorhanden',
        arbeitsscheinData: additionalData?.arbeitsscheinData ? 'Vorhanden' : 'Nicht vorhanden'
      });
      
      const docRef = await addDoc(this.getShareLinksCollection(), shareLinkData);
      
      console.log('‚úÖ Share Link erfolgreich in Firebase gespeichert:', {
        documentId: docRef.id,
        collection: 'shareLinks',
        token: token
      });
      
      // Verify the link was saved by reading it back
      try {
        const savedDoc = await getDoc(docRef);
        if (savedDoc.exists()) {
          console.log('‚úÖ ShareLink Verifizierung erfolgreich - Dokument existiert in Firebase');
          const savedData = savedDoc.data();
          console.log('üíæ Gespeicherte Daten:', {
            token: savedData.token,
            customerId: savedData.customerId,
            quoteId: savedData.quoteId
          });
        } else {
          console.error('‚ùå ShareLink Verifizierung fehlgeschlagen - Dokument nicht gefunden!');
        }
      } catch (verifyError) {
        console.warn('‚ö†Ô∏è Verifizierung √ºbersprungen:', verifyError);
      }
      
      return {
        id: docRef.id,
        customerId,
        quoteId,
        token,
        expiresAt,
        createdAt: new Date(),
        createdBy,
        arbeitsscheinHTML: additionalData?.arbeitsscheinHTML,
        arbeitsscheinData: additionalData?.arbeitsscheinData,
      };
    } catch (error) {
      console.error('‚ùå Fehler beim Erstellen des Share Links:', error);
      console.error('Details:', {
        customerId,
        quoteId,
        hasFirebaseConnection: !!this.getShareLinksCollection(),
        errorMessage: error instanceof Error ? error.message : 'Unbekannter Fehler'
      });
      throw error;
    }
  }

  async getShareLinkByToken(token: string): Promise<ShareLink | null> {
    try {
      if (!this.getShareLinksCollection()) {
        console.error('‚ùå ShareLinks collection nicht initialisiert!');
        throw new Error('ShareLinks collection not initialized');
      }
      
      console.log('üîç Suche ShareLink mit Token:', {
        token,
        tokenLength: token.length,
        collection: 'shareLinks'
      });
      
      const q = query(this.getShareLinksCollection(), where('token', '==', token));
      const querySnapshot = await getDocs(q);
      
      console.log('üìä Query-Ergebnis:', {
        gefundeneDokumente: querySnapshot.size,
        empty: querySnapshot.empty
      });
      
      if (querySnapshot.empty) {
        console.warn('‚ö†Ô∏è Kein ShareLink mit diesem Token gefunden');
        
        // Debug: Liste alle ShareLinks auf (nur f√ºr Debugging)
        try {
          const allLinks = await getDocs(this.getShareLinksCollection());
          console.log(`üìã Gesamt ShareLinks in DB: ${allLinks.size}`);
          allLinks.forEach(doc => {
            const data = doc.data();
            console.log(`  - ID: ${doc.id}, Token: ${data.token?.substring(0, 8)}..., Customer: ${data.customerId}`);
          });
        } catch (debugError) {
          console.error('Debug-Fehler:', debugError);
        }
        
        return null;
      }
      
      const doc = querySnapshot.docs[0];
      const data = doc.data();
      
      console.log('‚úÖ ShareLink gefunden:', {
        documentId: doc.id,
        customerId: data.customerId,
        quoteId: data.quoteId,
        hasArbeitsscheinHTML: !!data.arbeitsscheinHTML,
        expiresAt: data.expiresAt?.toDate ? data.expiresAt.toDate() : data.expiresAt
      });
      
      return {
        id: doc.id,
        customerId: data.customerId,
        quoteId: data.quoteId,
        token: data.token,
        expiresAt: data.expiresAt && typeof data.expiresAt.toDate === 'function'
          ? data.expiresAt.toDate()
          : data.expiresAt || new Date(),
        createdAt: data.createdAt && typeof data.createdAt.toDate === 'function'
          ? data.createdAt.toDate()
          : data.createdAt || new Date(),
        createdBy: data.createdBy,
        usedAt: data.usedAt && typeof data.usedAt.toDate === 'function'
          ? data.usedAt.toDate()
          : data.usedAt,
        arbeitsscheinHTML: data.arbeitsscheinHTML, // Include arbeitsschein data
        arbeitsscheinData: data.arbeitsscheinData,
      };
    } catch (error) {
      console.error('‚ùå Fehler beim Abrufen des Share Links:', error);
      console.error('Details:', {
        token,
        hasFirebaseConnection: !!this.getShareLinksCollection(),
        errorMessage: error instanceof Error ? error.message : 'Unbekannter Fehler'
      });
      throw error;
    }
  }

  async updateShareLinkUsage(linkId: string): Promise<void> {
    try {
      if (!this.getShareLinksCollection()) throw new Error('ShareLinks collection not initialized');
      
      const docRef = doc(this.getShareLinksCollection(), linkId);
      await updateDoc(docRef, {
        usedAt: serverTimestamp(),
      });
      
      console.log('‚úÖ Share Link Nutzung aktualisiert:', linkId);
    } catch (error) {
      console.error('‚ùå Fehler beim Aktualisieren der Share Link Nutzung:', error);
      throw error;
    }
  }

  async deleteExpiredShareLinks(): Promise<void> {
    try {
      if (!this.getShareLinksCollection()) throw new Error('ShareLinks collection not initialized');
      
      const now = new Date();
      const q = query(this.getShareLinksCollection(), where('expiresAt', '<', Timestamp.fromDate(now)));
      const querySnapshot = await getDocs(q);
      
      const deletions = querySnapshot.docs.map(doc => deleteDoc(doc.ref));
      await Promise.all(deletions);
      
      console.log(`‚úÖ ${querySnapshot.size} abgelaufene Share Links gel√∂scht`);
    } catch (error) {
      console.error('‚ùå Fehler beim L√∂schen abgelaufener Share Links:', error);
      throw error;
    }
  }

  // ==================== INVOICE RECOGNITION ====================

  async getRecognitionRules(): Promise<any[]> {
    try {
      if (!db) return [];
      const rulesCollection = collection(db, 'recognitionRules');
      const querySnapshot = await getDocs(rulesCollection);
      
      const rules: any[] = [];
      querySnapshot.forEach((doc) => {
        rules.push({
          id: doc.id,
          ...doc.data()
        });
      });
      
      return rules;
    } catch (error) {
      console.error('‚ùå Fehler beim Laden der Recognition Rules:', error);
      return [];
    }
  }

  async saveRecognitionRule(rule: any): Promise<void> {
    try {
      if (!db) throw new Error('Firebase not initialized');
      const rulesCollection = collection(db, 'recognitionRules');
      await setDoc(doc(rulesCollection, rule.id), rule);
      console.log('‚úÖ Recognition Rule gespeichert:', rule.id);
    } catch (error) {
      console.error('‚ùå Fehler beim Speichern der Recognition Rule:', error);
      throw error;
    }
  }

  async updateRecognitionRule(id: string, rule: any): Promise<void> {
    try {
      if (!db) throw new Error('Firebase not initialized');
      const rulesCollection = collection(db, 'recognitionRules');
      await updateDoc(doc(rulesCollection, id), rule);
      console.log('‚úÖ Recognition Rule aktualisiert:', id);
    } catch (error) {
      console.error('‚ùå Fehler beim Aktualisieren der Recognition Rule:', error);
      throw error;
    }
  }

  async deleteRecognitionRule(id: string): Promise<void> {
    try {
      if (!db) throw new Error('Firebase not initialized');
      const rulesCollection = collection(db, 'recognitionRules');
      await deleteDoc(doc(rulesCollection, id));
      console.log('‚úÖ Recognition Rule gel√∂scht:', id);
    } catch (error) {
      console.error('‚ùå Fehler beim L√∂schen der Recognition Rule:', error);
      throw error;
    }
  }

  async getEmailInvoices(): Promise<any[]> {
    try {
      if (!db) return [];
      const emailInvoicesCollection = collection(db, 'emailInvoices');
      const querySnapshot = await getDocs(emailInvoicesCollection);
      
      const invoices: any[] = [];
      querySnapshot.forEach((doc) => {
        const data = doc.data();
        invoices.push({
          id: doc.id,
          ...data,
          receivedDate: data.receivedDate && typeof data.receivedDate.toDate === 'function'
            ? data.receivedDate.toDate()
            : data.receivedDate || new Date(),
          processedDate: data.processedDate && typeof data.processedDate.toDate === 'function'
            ? data.processedDate.toDate()
            : data.processedDate
        });
      });
      
      return invoices;
    } catch (error) {
      console.error('‚ùå Fehler beim Laden der Email Invoices:', error);
      return [];
    }
  }

  async saveEmailInvoice(invoice: any): Promise<void> {
    try {
      if (!db) throw new Error('Firebase not initialized');
      const emailInvoicesCollection = collection(db, 'emailInvoices');
      await setDoc(doc(emailInvoicesCollection, invoice.id), {
        ...invoice,
        receivedDate: Timestamp.fromDate(invoice.receivedDate),
        processedDate: invoice.processedDate ? Timestamp.fromDate(invoice.processedDate) : null
      });
      console.log('‚úÖ Email Invoice gespeichert:', invoice.id);
    } catch (error) {
      console.error('‚ùå Fehler beim Speichern der Email Invoice:', error);
      throw error;
    }
  }

  async updateEmailInvoice(id: string, invoice: any): Promise<void> {
    try {
      if (!db) throw new Error('Firebase not initialized');
      const emailInvoicesCollection = collection(db, 'emailInvoices');
      await updateDoc(doc(emailInvoicesCollection, id), {
        ...invoice,
        receivedDate: Timestamp.fromDate(invoice.receivedDate),
        processedDate: invoice.processedDate ? Timestamp.fromDate(invoice.processedDate) : null
      });
      console.log('‚úÖ Email Invoice aktualisiert:', id);
    } catch (error) {
      console.error('‚ùå Fehler beim Aktualisieren der Email Invoice:', error);
      throw error;
    }
  }

  // ==================== CALENDAR EVENTS ====================
  async getCalendarEvents(): Promise<CalendarEvent[]> {
    try {
      if (!this.checkFirebase() || !this.getCalendarEventsCollection()) return [];
      
      const querySnapshot = await getDocs(
        query(this.getCalendarEventsCollection(), orderBy('date', 'desc'))
      );
      
      const events: CalendarEvent[] = [];
      querySnapshot.forEach((doc) => {
        const data = doc.data();
        events.push({
          id: doc.id,
          ...data,
          date: data.date && typeof data.date.toDate === 'function' 
            ? data.date.toDate() 
            : data.date,
          startTime: data.startTime && typeof data.startTime.toDate === 'function'
            ? data.startTime.toDate()
            : data.startTime,
          endTime: data.endTime && typeof data.endTime.toDate === 'function'
            ? data.endTime.toDate()
            : data.endTime,
          importedAt: data.importedAt && typeof data.importedAt.toDate === 'function'
            ? data.importedAt.toDate()
            : data.importedAt,
        } as CalendarEvent);
      });
      
      return events;
    } catch (error) {
      console.error('‚ùå Fehler beim Laden der Kalender-Events:', error);
      return [];
    }
  }

  async getCalendarEventsByCustomer(customerId: string): Promise<CalendarEvent[]> {
    try {
      if (!this.checkFirebase() || !this.getCalendarEventsCollection()) return [];
      
      const q = query(
        this.getCalendarEventsCollection(),
        where('customerId', '==', customerId),
        orderBy('date', 'desc')
      );
      
      const querySnapshot = await getDocs(q);
      const events: CalendarEvent[] = [];
      
      querySnapshot.forEach((doc) => {
        const data = doc.data();
        events.push({
          id: doc.id,
          ...data,
          date: data.date && typeof data.date.toDate === 'function' 
            ? data.date.toDate() 
            : data.date,
          startTime: data.startTime && typeof data.startTime.toDate === 'function'
            ? data.startTime.toDate()
            : data.startTime,
          endTime: data.endTime && typeof data.endTime.toDate === 'function'
            ? data.endTime.toDate()
            : data.endTime,
          importedAt: data.importedAt && typeof data.importedAt.toDate === 'function'
            ? data.importedAt.toDate()
            : data.importedAt,
        } as CalendarEvent);
      });
      
      return events;
    } catch (error) {
      console.error('‚ùå Fehler beim Laden der Kunden-Kalender-Events:', error);
      return [];
    }
  }

  async addCalendarEvent(event: Omit<CalendarEvent, 'id'>): Promise<string> {
    try {
      if (!this.checkFirebase() || !this.getCalendarEventsCollection()) {
        throw new Error('Firebase not available');
      }
      
      const eventData = {
        ...event,
        date: event.date instanceof Date ? Timestamp.fromDate(event.date) : event.date,
        startTime: event.startTime instanceof Date ? Timestamp.fromDate(event.startTime) : event.startTime,
        endTime: event.endTime instanceof Date ? Timestamp.fromDate(event.endTime) : event.endTime,
        importedAt: serverTimestamp(),
      };
      
      const docRef = await addDoc(this.getCalendarEventsCollection(), eventData);
      console.log('‚úÖ Kalender-Event erstellt:', docRef.id);
      return docRef.id;
    } catch (error) {
      console.error('‚ùå Fehler beim Erstellen des Kalender-Events:', error);
      throw error;
    }
  }

  async updateCalendarEvent(eventId: string, updates: Partial<CalendarEvent>): Promise<void> {
    try {
      if (!this.checkFirebase() || !this.getCalendarEventsCollection()) {
        throw new Error('Firebase not available');
      }
      
      const updateData: any = { ...updates };
      
      if (updates.date instanceof Date) {
        updateData.date = Timestamp.fromDate(updates.date);
      }
      if (updates.startTime instanceof Date) {
        updateData.startTime = Timestamp.fromDate(updates.startTime);
      }
      if (updates.endTime instanceof Date) {
        updateData.endTime = Timestamp.fromDate(updates.endTime);
      }
      
      await updateDoc(doc(this.getCalendarEventsCollection(), eventId), updateData);
      console.log('‚úÖ Kalender-Event aktualisiert:', eventId);
    } catch (error) {
      console.error('‚ùå Fehler beim Aktualisieren des Kalender-Events:', error);
      throw error;
    }
  }

  async deleteCalendarEvent(eventId: string): Promise<void> {
    try {
      if (!this.checkFirebase() || !this.getCalendarEventsCollection()) {
        throw new Error('Firebase not available');
      }
      
      await deleteDoc(doc(this.getCalendarEventsCollection(), eventId));
      console.log('‚úÖ Kalender-Event gel√∂scht:', eventId);
    } catch (error) {
      console.error('‚ùå Fehler beim L√∂schen des Kalender-Events:', error);
      throw error;
    }
  }
}

export const firebaseService = new FirebaseService();